+++
title = "A Design is a Mold for Code"
date = 2024-01-15
[taxonomies]
tags = ['code']
+++

I'm always in search of good metaphors for software design. Good or not, here's one:

> A Design is a Mold for Code

In manufacturing, a mold is a hollow shape that fills with fluid material which expands into the space and sets to form a casting. 

<div style="text-align: center; width: 60%; margin: 0 auto;">
  <img src="../img/dall-e-muffin-pan.png"/>
  <p style="font-style: italic">Image: A useful mold. Generated by Dall-E</p>
</div>

Like manufacturing, code fills the [negative space](https://en.wikipedia.org/wiki/Negative_space) of a software design. Imagine two engineering teams who independently "fill" (implement) a design, and the design is the set of standards for a web browser. The two implementations are Chrome and Firefox. The two browsers have independent codebases<sup>\[[1](#notes)\]</sup> which take vastly different shapes, but as far as web standards are concerned, the two are equal. You could switch from Chrome to Firefox (which I [recommend](https://www.eff.org/deeplinks/2021/12/chrome-users-beware-manifest-v3-deceitful-and-threatening)) and still browse compliant web pages with no discernible change. 

Programmers who also like math sometimes call two pieces of code which can be swapped [isomorphic](https://blog.ploeh.dk/2018/01/08/software-design-isomorphisms/) with respect to the spec.

It's important not to reverse the causality: a design causes the work product, not the converse. A mold causes a casting, and a software design causes code. Nevertheless, to some extent, one can go in reverse, i.e. reconstruct a mold from a casting or infer a design from code. 

The reconstructed mold might lose some fidelity, like sharp edges or precise dimensions, but it's far worse for code. Looking at code without supplemental information, a new dev can only infer a dim, vague notion of its design. She might even sense the mind(s) behind the design. However, it would be costly if even possible to losslessly reconstruct the design, i.e. to such a fidelity that it could be the basis for an isomorphic implementation.

In pseudocode:

```
[Test]
fn Reverse_ProducesIsomorphicDesign()
    let design1 : ...
    let code1 = implement(design1)
    let design2 = reverse(code1)
    let code2 = implement(design2)
    assert(isomorphic(code1, code2)) // Fails
```

Above: The roundtrip from a design to code back to design is lossy.

There are a few reasons for this:

- A codebase maybe too large to fit into a dev's head. The codebases for Chrome and Firefox are huge. Like the limited context window of ChatGPT, a human has limited working memory and forgets. Though with time and repetition, knowledge transitions to long-term memory.
- It's hard to infer high-level concepts from low-level details. For example, decompiling assembly back to C.
- Design and code have a many-to-many relationship.
	- There can be many implementations that satisfy a design.
	- There can be many designs that result in the same code.

This is a problem for software that outlives its creator(s). The software will languish unless knowledge is [retained](https://en.wikipedia.org/wiki/Organizational_memory) and [replicated](https://en.wikipedia.org/wiki/Bus_factor).

There are some things developers can do to keep their software alive:

- Write down the design. Use [natural language](https://en.wikipedia.org/wiki/Literate_programming)
- Make the [design apparent in the code](https://www.pathsensitive.com/2018/01/the-design-of-software-is-thing-apart.html)
- Use [precise abstractions](https://www.pathsensitive.com/2022/03/abstraction-not-what-you-think-it-is.html)
- Use [effective](https://argumatronic.com/posts/2018-09-02-effective-metaphor.html) [metaphors](https://gist.github.com/onlurking/fc5c81d18cfce9ff81bc968a7f342fb1#tacit-knowledge-and-documentation)
- Make the code [fit in your head](https://www.oreilly.com/library/view/code-that-fits/9780137464302/)

---

## Notes

1. Firefox and Chrome are not truly independent by this definition. Plenty of people who have worked on one browser have also worked on the other. Moreover, as open source projects, both teams can see the other's code. [Chromium source](https://source.chromium.org/chromium/chromium/src/+/main:) and [Firefox source](https://searchfox.org/mozilla-central/source) 
